Hai perfettamente ragione. **Maniacale** è la parola d'ordine.

Analizzando il tuo `tree`, vedo che il generatore ha creato i file del modulo `content` (`content.controller.ts`, `content.service.ts`, ecc.) direttamente nella root di `apps/backend/src/app`, invece che in una sottocartella dedicata `apps/backend/src/app/content`.

È un po' "disordinato" (flat structure), ma per non rompere i collegamenti che Nx ha già creato in `app.module.ts`, **lavoreremo rispettando questa struttura**, ma isolando la nostra logica nuova (il Repository) in una cartella dedicata per mantenere pulizia.

Ecco il piano d'azione chirurgico adattato alla tua struttura attuale.

---

### 1. Verifica preliminare: La Libreria Condivisa

Assicuriamoci che l'interfaccia `ContentItem` sia esportata correttamente, altrimenti il backend non la vedrà.

**File:** `libs/shared-data/src/index.ts`
Controlla che contenga:

```typescript
export * from './lib/shared-data';

```

*(Se non c'è, aggiungilo. Se c'è già, procedi).*

---

### 2. Creazione della Cartella Repository

Visto che i file sono "sparsi" in `app`, creiamo una cartella per raggruppare la logica di accesso ai dati.

Esegui:

```bash
mkdir -p apps/backend/src/app/repository

```

---

### 3. Implementazione (Codice Adattato ai Percorsi)

Ora creiamo i file. Nota bene i percorsi: sono relativi alla cartella `repository` appena creata.

#### A. L'Interfaccia (Contratto)

**File:** `apps/backend/src/app/repository/content.repository.interface.ts`

```typescript
import { ContentItem } from '@json-pages/shared-data'; // Assicurati che l'alias nel tsconfig.base.json coincida. Se l'IDE si lamenta, usa il percorso relativo ../../../../../libs/shared-data/src

export interface IContentRepository {
  findAll(collection: string): Promise<ContentItem[]>;
  findById(collection: string, id: string): Promise<ContentItem | null>;
  create(collection: string, item: ContentItem): Promise<void>;
  update(collection: string, id: string, item: ContentItem): Promise<void>;
  delete(collection: string, id: string): Promise<void>;
}

export const CONTENT_REPOSITORY = 'CONTENT_REPOSITORY';

```

#### B. L'Implementazione (JSON Engine)

Qui dobbiamo stare attenti al percorso dei dati.
**File:** `apps/backend/src/app/repository/json-file.repository.ts`

```typescript
import { Injectable, NotFoundException, InternalServerErrorException } from '@nestjs/common';
import { IContentRepository } from './content.repository.interface';
import { ContentItem } from '@json-pages/shared-data';
import * as fs from 'fs/promises';
import * as path from 'path';

@Injectable()
export class JsonFileRepository implements IContentRepository {
  // Percorso assoluto basato sulla root del progetto
  private readonly basePath = path.join(process.cwd(), 'apps/backend/data/content');

  private getFilePath(collection: string): string {
    return path.join(this.basePath, `${collection}.json`);
  }

  async findAll(collection: string): Promise<ContentItem[]> {
    try {
      const filePath = this.getFilePath(collection);
      // Verifica se il file esiste per evitare crash brutali
      try {
        await fs.access(filePath);
      } catch {
        console.warn(`File non trovato: ${filePath}. Ritorno array vuoto.`);
        return [];
      }

      const data = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(data) as ContentItem[];
    } catch (error) {
      console.error(`Errore lettura ${collection}:`, error);
      throw new InternalServerErrorException(`Errore lettura dati per ${collection}`);
    }
  }

  async findById(collection: string, id: string): Promise<ContentItem | null> {
    const items = await this.findAll(collection);
    return items.find((item) => item.id === id) || null;
  }

  async create(collection: string, item: ContentItem): Promise<void> {
    const items = await this.findAll(collection);
    items.push(item);
    await this.saveFile(collection, items);
  }

  async update(collection: string, id: string, item: ContentItem): Promise<void> {
    const items = await this.findAll(collection);
    const index = items.findIndex((i) => i.id === id);
    if (index === -1) throw new NotFoundException(`Item ${id} not found`);
    items[index] = item;
    await this.saveFile(collection, items);
  }

  async delete(collection: string, id: string): Promise<void> {
    const items = await this.findAll(collection);
    const newItems = items.filter((i) => i.id !== id);
    await this.saveFile(collection, newItems);
  }

  private async saveFile(collection: string, data: ContentItem[]): Promise<void> {
    await fs.writeFile(this.getFilePath(collection), JSON.stringify(data, null, 2));
  }
}

```

---

### 4. Cablaggio del Modulo

Dobbiamo collegare questi nuovi file al `ContentModule` che si trova nella root di `app`.

**File:** `apps/backend/src/app/content.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { ContentService } from './content.service';
import { ContentController } from './content.controller';
// Nota i percorsi di import che puntano alla cartella ./repository
import { JsonFileRepository } from './repository/json-file.repository';
import { CONTENT_REPOSITORY } from './repository/content.repository.interface';

@Module({
  controllers: [ContentController],
  providers: [
    ContentService,
    {
      provide: CONTENT_REPOSITORY, // TOKEN
      useClass: JsonFileRepository, // IMPLEMENTAZIONE REALE
    },
  ],
})
export class ContentModule {}

```

---

### 5. Refactoring del Service

Il service generato da Nx ha metodi vuoti o mockati. Ora li colleghiamo al Repository.

**File:** `apps/backend/src/app/content.service.ts`

```typescript
import { Inject, Injectable } from '@nestjs/common';
// Importiamo l'interfaccia e il token
import { CONTENT_REPOSITORY, IContentRepository } from './repository/content.repository.interface';
import { ContentItem } from '@json-pages/shared-data';

@Injectable()
export class ContentService {
  constructor(
    @Inject(CONTENT_REPOSITORY) private readonly repository: IContentRepository
  ) {}

  // Passiamo sempre 'collection' come primo argomento
  findAll(collection: string) {
    return this.repository.findAll(collection);
  }

  findOne(collection: string, id: string) {
    return this.repository.findById(collection, id);
  }

  create(collection: string, item: ContentItem) {
    return this.repository.create(collection, item);
  }

  update(collection: string, id: string, item: ContentItem) {
    return this.repository.update(collection, id, item);
  }

  remove(collection: string, id: string) {
    return this.repository.delete(collection, id);
  }
}

```

---

### 6. Refactoring del Controller (Parametri Dinamici)

Qui avviene la magia dell'astrazione. Il controller non deve rispondere a `/content`, ma a `/content/:collection`.

**File:** `apps/backend/src/app/content.controller.ts`

```typescript
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ContentService } from './content.service';
import { ContentItem } from '@json-pages/shared-data';

@Controller('content')
export class ContentController {
  constructor(private readonly contentService: ContentService) {}

  // Esempio chiamata: GET /api/content/items
  @Get(':collection')
  findAll(@Param('collection') collection: string) {
    return this.contentService.findAll(collection);
  }

  // Esempio chiamata: GET /api/content/items/1
  @Get(':collection/:id')
  findOne(@Param('collection') collection: string, @Param('id') id: string) {
    return this.contentService.findOne(collection, id);
  }

  @Post(':collection')
  create(@Param('collection') collection: string, @Body() contentItem: ContentItem) {
    // Forziamo la collection dentro l'item per coerenza
    contentItem.collection = collection;
    return this.contentService.create(collection, contentItem);
  }

  @Patch(':collection/:id')
  update(
    @Param('collection') collection: string,
    @Param('id') id: string,
    @Body() contentItem: ContentItem
  ) {
    return this.contentService.update(collection, id, contentItem);
  }

  @Delete(':collection/:id')
  remove(@Param('collection') collection: string, @Param('id') id: string) {
    return this.contentService.remove(collection, id);
  }
}

```

---

### ✅ Verifica Finale

Se hai copiato tutto correttamente, ora puoi lanciare il server:

```bash
npx nx serve backend

```

E testare l'endpoint (o via browser o via `curl`):
`http://localhost:3000/api/content/items`

Dovresti vedere il JSON che abbiamo scritto manualmente in `apps/backend/data/content/items.json`.

Dimmi se compila tutto (in particolare controlla se NestJS trova il modulo `@json-pages/shared-data`). Se dà errore sugli import, lo risolviamo subito.